    The majority of work this summer has focused on finding matrix
orderings that minimize the fill generated by the Cholesky
factorization. First, I implemented the adjacency array generators
for torus and three-dimensional matrices in C. Once this was
completed, Mathias suggested that we could use a genetic algorithm
to generate more effective matrix orderings. I have implemented a
genetic algorithm to search for optimal matrix orderings for the
Cholesky factorization. The framework of this algorithm is written
in C, and should be easily adaptable to other problems for which a
genetic algorithm can be implemented. I implemented this entirely
from scratch myself, choosing to ignore genetic algorithm packages
in order to learn for myself. The algorithm uses a cost function
supplied by Mathias that uses the fill generated by the ordering 
in order to determine the “fitness” of a certain individual. With 
its currently implemented genetic operators this genetic algorithm 
is useful for permutation problems (the “genes” of the algorithm 
are permutations of a sequence of numbers with no repeated elements). 
The framework, however, could be adapted to other problems with 
simply replacing the genetic operators of selection, crossover, 
and mutation.
    Currently two types of parent selection have implemented. Each 
of these implementations utilizes a pseudorandom number generator 
in order to select the parents. The first parent selection method 
directly uses the cost function in order to assign a probability 
to each individual. The second parent selection method uses the 
rank of an ordering relative to the others in order to assign the 
probability that it is selected. In this method, the best parent is 
given a much larger probability to be selected than the worst 
ordering. At the moment, the first method is preferred because the 
more even probabilities allow for more variation to be preserved 
within the child population. 
    There are currently two types of permutation crossovers implemented 
in this genetic algorithm. Neither of these is directly related to 
the matrix problems in question, and is probably the portion of 
the algorithm that stands to be improved the most. The first selects 
a random segment of the first parent’s ordering, and then fills in 
the child’s missing elements in the order that they appear in the 
second parent. The second crossover that has been implemented takes 
the average position of each element in each parent, and then inserts 
these elements into the child in sorted order. So far, this method has 
seemed to be less effective at preserving the effectiveness of the 
ordering then the first method. For both of these crossover methods 
there are certain protections implemented in order to preserve the 
genetic variation of the population. A cross requires that parents 
are distinct orders, and the child that is generated is also 
guaranteed to be unique in regards to each of its parent’s orderings. 
This should keep variation within the population, which we believe is 
key for this algorithm.
    Finally, random mutation is also implemented in the algorithm. The 
chance of this mutation occurring as well as the severity of these 
mutations is variable and a parameter that still needs to be optimized. 
So far, three types of mutations have been introduced to the system. 
The first will swap random segments of a fixed length within an ordering. 
The second type of mutation will remove a segment of a fixed length 
from a random location, shift the remainder of the ordering forward 
and reinsert the removed section from the tail. The final mutation 
will take a segment of a fixed length and invert it within the matrix 
ordering. The first type of mutation seems to be the most effective 
currently. 
    By modifying the data structures that the genetic algorithm 
requires, we have allowed for the population to dynamically grow. 
With increased population sizes, we seem to be able to reach higher 
quality solutions in a constant number of generations. With the 
increased population size, however, the execution time for a 
single generation also increases greatly. Since this algorithm 
is embarrassingly parallel, however, it seems that the ultimate 
goal should be to minimize the number of generations, and thus 
increased population sizes are desirable.

    Second Update:
    More work has been completed on the genetic algorithm, as 
well as more testing. We believe that allowing the population 
to grow is crucial for minimizing the number of generations that 
the algorithm is required to run. Because this algorithm is 
embarrassingly parallel, it seems to us that the objective should 
be to minimize the number of generations that it takes. We have 
also implemented a parameter to weight the amount of children vs. 
parents passed on each generation as well as three more types of 
crossovers. Also, a signal handler has been implemented allowing 
us to see the current results of the algorithm without losing the 
progress we have made. This allowed us to run the code for long 
periods of time (overnight). Despite all of these improvements, 
after looking at it with the signal handler it seems that our 
attempts to improve this algorithm for this question have not 
been successful, and development has been suspended as of 
August 2014. 

