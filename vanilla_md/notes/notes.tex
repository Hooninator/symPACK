\documentclass[a4paper]{article}

\usepackage{todonotes}
\usepackage{adjustbox}
\usepackage{scalefnt}
\usepackage{algorithm2e}
\usepackage{paralist}
\usepackage{tikz}
\usepackage{pgf}
\usetikzlibrary{patterns,calc}
\usetikzlibrary{positioning}


\newcommand{\adj}[1]{\ensuremath{Adj_{#1}}}
\newcommand{\reach}[1]{\ensuremath{R_{#1}}}
\newcommand{\reachb}[1]{\ensuremath{\bar{R}_{#1}}}



\tikzstyle{treenode} = [circle,fill=white,solid, draw=black, text centered,minimum size=2.6em, text width=2.6em,inner sep=0pt]












\title{Parallel Minimum degree ordering}
\date{}

\begin{document}
\maketitle


When factoring sparse matrices, new non-zero entries are created. This phenomenon,
known as ``fill-in'', has a significant impact on performance. This amount
of extra non-zero entries created depends on column ordering. Determining good
column orderings is therefore an extremely precomputing phase of any sparse matrix
factorization.

\section{Elimination game}

The \textbf{elimination game} consists in simulating the factorization itself while
monitoring newly created non-zero entries. Based on this knowledge, it is possible to
design heuristics intenting to reduce the amount of fill-in.

Sparse matrix row-column dependencies are represented using a graph structure $\mathcal{G} = (V,E)$.
Each node $v \in V$ corresponds to a column in the sparse matrix. Every edge $(u,v) \in E$ between two
nodes $u$ and $v$ represents a dependency between these two columns, i.e. a non zero entry in $(u,v)$
and $(v,u)$ entries of the sparse matrix. 

At every step, the elimination game processes as follows:
  \begin{enumerate}
    \item Pick a node $v$ and eliminate it.
    \item Create a clique between all nodes adjacent to $v$
  \end{enumerate}

\section{Minimum degree algorithm}

\subsection{Parallelization schemes}

\begin{itemize}
  \item algorithms not explicitely changing the graph
  \item algorithms changing the graph
\end{itemize}



\section{Finding indistinguishable nodes when computing reachable set}

\begin{algorithm}
\DontPrintSemicolon
\KwIn{ $v$ is the node eliminated at step $s$. \reach{v} is its reachable set. $marker$ and $label$ arrays, $tag$}

$label(v) = s$\;
$indistCount = 0$\;


$tag = tag+1$\;
$tag_v = tag$\;
\ForAll{node $u \in \reach{v}$}{
  $mask(u) = tag_v$\;
}


\ForAll{node $t \in \reach{v}$}{
  $tag = tag+1$\;
  $indist,deg(t) \gets update\_degree(t,v,deg(v),label,marker,tag,tag_v,mask)$\;
  
  \If{indist}{
    $s = s+1$\;
    $label(t) = s$\;
    $indistCount \gets indistCount +1$\;
  }
}

\ForAll{node $t \in \reach{v}$}{
  \If{$label(t) = 0$}{
    $deg(t) \gets deg(t) - indistCount$\;
  }
}

\caption{Sketch of the MDO algorithm calling $update\_degree$}
\end{algorithm}


\begin{algorithm}
\DontPrintSemicolon
\caption{$update\_degree$}
\KwIn{
       \begin{compactenum}
        \item $u$, node of which we're computing the reachable set (starting point of the exploration).
        \item $v$, node eliminated at current step. 
        \item $deg(v)$, degree of $v$. 
        \item $label$, array of size $n$ indicating if a node has been labeled or not.
        \item $marker$, array of size $n$ used to mark explored nodes with value $tag$.
        \item $tag_v$, special tag value used to mark nodes in \reach{v}.
        \item $mask$, array of size $n$ used to mark nodes in \reach{v} with $tag_v$.
       \end{compactenum}
     }
\KwOut{
       \begin{compactenum}
        \item $indist$, boolean indicating if $v$ and $u$ are indistinguishable.
        \item $\bar{deg}(u)$, updated degree of $u$ after the elimination of $v$. 
       \end{compactenum}
      }
\;
$\bar{deg}(u) \gets deg(v) -1$\;
$explore \gets \{u\}$\;
$indist \gets true$\;
$count \gets 1$\;

\ForAll{node $t$ in $explore$}{
  \ForAll{node $x$ in \adj{t}}{
    \If{$marker(x) \neq tag$}{
      \If{$label(x) \neq 0$}{
        \If{$x \neq v$}{
          $explore \gets explore \cup \{x\}$\;
        }
      }
      \Else{
        \If{$mask(x) \neq tag_v$}{
          $indist \gets false$\;
          $\bar{deg}(u) \gets \bar{deg}(u)+1$\;
        }
        \Else{
          $count \gets count +1$\;
        }
      }
      $marker(x) = tag$\;
    }
  }
}

\If{$indist = true$ AND $count + 1 \neq deg(v)$}{
  $indist \gets false$\;
}

%\If{$ \reach{u} \cup {u} = \reach{v} \cup {v}$}{
%  $indist \gets true$\;
%}
%else{
%  $indist \gets false$\;
%}

%$\reachb{u} \gets \reach{u} \cup \reach{v}$\;


\end{algorithm}

\section{Performance}

\begin{table}
\begin{tabular}{c | c | c | c | c | c}
P & Reach & Reach \& comp. & Reach, comp. \& mass. & Explicit & Explicit \& mass. \\
1   &     & 4.9444  & 5.2108  & 3.5210  & 0.2097  \\
4   &     & 1.9232  & 2.1678  & 1.4694  & 0.2074  \\
8   &     & 1.1575  & 1.4402  & 0.9910  & 0.1702  \\
16  &     & 0.8842  & 1.3877  & 0.8215  & 0.1937  \\
24  &     & 0.8289  & 1.3861  & 0.8287  & 0.2133  \\
\end{tabular}
\end{table}


\end{document}
